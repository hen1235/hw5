%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
	stack<int> whileStack;
	bool mainExist = false;
 	type_t funcType = _NULL;
	extern int yylex();
	extern int yylineno;
	extern char * yytext;
	int yyerror(const char * message);
	void match_operands(type_t type1, type_t type2, bool flag);
	stack<Tuple> tables;
	stack<int> offsets;
	vector<Var> args, params;
	stack<vector<Var> > callParams;
	type_t get_variable_type(string name);
	bool check_func_exist(string name, vector<Var> argList, type_t* retType);
	int get_arr_size_and_type(string name, type_t* type, int* size);
	string types[6] = {"INT","BOOL","STRING","BYTE","VOID","NONE"};

	stack<vector<int> > regsStack;
	CodeBuffer& CodeBuffer = CodeBuffer::instance();
	int numOfStrings = 0;
	void free_reg_list(vector<int>& regs);
	int get_empty_reg();
	void free_reg(int num);
	int get_variable_off(string name);
	int get_arr_off(string name);
	int get_offset_of_vars_in_stack();
	void push_regs();
	void pop_regs();
	// void print_empty_regs();

%}



%token ID NUM B STRING TRUE FALSE VOID INT
%token IF
%nonassoc IFX
%nonassoc ELSE 
%token BOOL BREAK COMMA BYTE RETURN SC WHILE ERROR
%right ASSIGN 
%left OR
%left AND
%left EQ NEQ
%nonassoc LT GT LTE GTE
%left ADD SUB
%left DIV MUL
%right NOT
%left LBRACE RBRACE
%left LBRACK RBRACK LPAREN RPAREN 



%%

Program	:	
		{
			/* insert print function to symbol table */
			Tuple tuple;
			vector<Var> printArgs;
			Var var1(_STRING,-1,"a");
			printArgs.push_back(var1);
			BaseRecord* printRecord = new FuncRecord("print",_VOID,printArgs);
			tuple.table.push_back(printRecord);

			/* insert printi function to symbol table */
			vector<Var> printiArgs;
			Var var2(_INT,-1,"a"); 
			printiArgs.push_back(var2);
			BaseRecord* printiRecord = new FuncRecord("printi",_VOID,printiArgs);
			tuple.table.push_back(printiRecord);

			tuple.parent = NULL;
			tables.push(tuple);
			offsets.push(0);
			
			CodeBuffer.emitData("DivByZeroMsg: 	.asciiz \"Error division by zero\n\"");
			CodeBuffer.emit("ZeroDivision:");

			// CodeBuffer.emit("addu $sp,$sp,-4");
			// CodeBuffer.emit("sw $fp,($sp)");
			// CodeBuffer.emit("addu $sp,$sp,-4");
			// CodeBuffer.emit("sw $ra,($sp)");

			CodeBuffer.emit("la $a0,DivByZeroMsg");
			CodeBuffer.emit("li $v0,4");
			CodeBuffer.emit("syscall");
			CodeBuffer.emit("li $v0,10");
			CodeBuffer.emit("syscall");

			CodeBuffer.emitData("IndexOutOfBoundsMsg: 	.asciiz \"Error index out of bounds\n\"");
			CodeBuffer.emit("IndexOutOfBounds:");
			CodeBuffer.emit("la $a0,IndexOutOfBoundsMsg");
			CodeBuffer.emit("li $v0,4");
			CodeBuffer.emit("syscall");
			CodeBuffer.emit("li $v0,10");
			CodeBuffer.emit("syscall");

			CodeBuffer.emit(".globl print");
			CodeBuffer.emit(".ent print");
			CodeBuffer.emit("print:");
			CodeBuffer.emit("lw $a0,0($sp)");
			CodeBuffer.emit("li $v0,4");
			CodeBuffer.emit("syscall");
			CodeBuffer.emit("jr $ra");
			CodeBuffer.emit(".end print");


			CodeBuffer.emit(".globl printi");
			CodeBuffer.emit(".ent printi");
			CodeBuffer.emit("printi:");
			CodeBuffer.emit("lw $a0,0($sp)");
			CodeBuffer.emit("li $v0,1");
			CodeBuffer.emit("syscall");
			CodeBuffer.emit("jr $ra");
			CodeBuffer.emit(".end printi");

		} Funcs 
		{ 
			
			string tmp = yytext;
			
			if((tmp.compare("}") != 0) && (tmp.empty() == 0)){
				errorSyn(yylineno);
				exit(0);
			}
			if(mainExist == false){
				errorMainMissing();
				exit(0);
			} 
		} CLOSESCOPE
		;

Funcs	: /* epsilon */
		| FuncDecl Funcs
		;

FuncDecl	:  RetType 
			{ 
				funcType = $1.type;
			} 
				ID
			{ 					
				$3.type = $1.type;	

			} 
				LPAREN Formals RPAREN 
			{
				type_t type;
				if($1.type == _VOID && $3.name == "main" && args.empty()){
					mainExist = true;
				}
				if(check_func_exist($3.name, args,NULL)){
					errorDef(yylineno, $3.name);
					exit(0);
				}

				BaseRecord* funcRecord = new FuncRecord($3.name, $1.type, args);
				tables.top().table.push_back(funcRecord);

				CodeBuffer.emit(".globl " + $3.name);
				CodeBuffer.emit(".ent " + $3.name);
				CodeBuffer.emit($3.name + ":");

				if($3.name == "main"){
					CodeBuffer.emit("addu $fp,$sp,-4");	
				} 
			}	
				LBRACE OPENSCOPEIF 
			{				
				BaseRecord* record;
				int size1, res, size, offset = offsets.top();
				type_t type1, type2;
				
				for(vector<Var>::iterator it = args.begin(); it != args.end(); ++it){
					if((res = get_arr_size_and_type(it->name, &type1, &size1)) == 0 || 
						(type2 = get_variable_type(it->name)) != _NULL || check_func_exist(it->name,vector<Var>(),NULL)){ // ID var or arr don't exist
						errorDef(yylineno, it->name);
						exit(0);
					}
					if(it->size > 0){
						offset -= it->size;
						record = new ArrRecord(it->name,it->type,offset,it->size);
					}
					else {
						offset--;
						record = new Record(it->name,it->type,offset);
					}
					
					tables.top().table.push_back(record);
				}
				args.clear();
			} Statments M RBRACE CLOSESCOPEIF 
			{ 
				funcType = _NULL;
				if($3.name == "main"){
					CodeBuffer.emit("li $v0, 10");
					CodeBuffer.emit("syscall");
				} 
				else {
					CodeBuffer.emit("jr $ra");
				}
				CodeBuffer.emit(".end " + $3.name);
				CodeBuffer.bpatch($12.nextList, $13.quad);
				// CodeBuffer.bpatch($12.trueList, $13.quad);
				// CodeBuffer.bpatch($12.falseList, $13.quad);
			}
			;

RetType	: Type { $$.type = $1.type; }
		| VOID { $$.type = _VOID; }
		;

Formals	: /* epsilon */
		| FormalsList
		;

FormalsList	: FormalDecl
			| FormalDecl COMMA FormalsList
			;

FormalDecl	: Type ID
			{ 				
				type_t type;
				if(check_func_exist($2.name, vector<Var>(),NULL)){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				Var var($1.type,-1,$2.name);

				args.push_back(var);				
			}
			| Type ID LBRACK NUM RBRACK 
			{ 
				type_t type;
				if(check_func_exist($2.name, vector<Var>(),NULL)){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				if($4.val <= 0 || $4.val >= 256){
					errorInvalidArraySize(yylineno,$2.name);
					exit(0);
				}
				Var var($1.type,$4.val,$2.name);
				args.push_back(var);
			}
			| Type ID LBRACK NUM B RBRACK 
			{ 
				type_t type;
				if(check_func_exist($2.name, vector<Var>(),NULL)){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				if($4.val <= 0){
					errorInvalidArraySize(yylineno,$2.name);
					exit(0);
				}				
				if($4.val >= 256){
					errorByteTooLarge(yylineno,NumberToString($4.val));
					exit(0);
				}
				Var var($1.type,$4.val,$2.name);
				args.push_back(var);
			}
			;

Statments	: Statement { $$ = $1; }
			| Statments Statement
			{
				// $$.trueList = CodeBuffer.merge($1.trueList,$2.trueList);
				// $$.falseList = CodeBuffer.merge($1.falseList,$2.falseList);
				$$.nextList = CodeBuffer.merge($1.nextList,$2.nextList);
			}
			;

Statement 	: LBRACE OPENSCOPEIF Statments CLOSESCOPEIF RBRACE { $$ = $1; }
			| Type ID SC
			{ 				
				type_t type;
				int size, res;
				res = get_arr_size_and_type($2.name, &type, &size);
				type = get_variable_type($2.name);
				if(res == 0 || type != _NULL){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				if(check_func_exist($2.name, vector<Var>(),NULL)){
					errorDef(yylineno, $2.name);
					exit(0);
				}

				$2.type = $1.type;
				$2.size = -1;
				BaseRecord* record = new Record($2.name, $1.type, offsets.top());
				tables.top().table.push_back(record);
				offsets.top()++;

				CodeBuffer.emit("subu $sp,$sp,4"); // space in stack for variable
				CodeBuffer.emit("sw $0,($sp)"); // initialize var to zero
				free_reg($2.place);
				$2.place = -1;
				// if($2.type == _BOOL){
				// }
				// else{

				// }
			}
			| Type ID ASSIGN Exp SC
			{ 				
				type_t type = get_variable_type($2.name);
				if(check_func_exist($2.name, vector<Var>(),NULL)){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				if(type != _NULL){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				else if($1.type == _INT && ($4.type != _INT && $4.type != _BYTE )){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type != _INT && $1.type != $4.type){
					errorMismatch(yylineno); 
					exit(0); 
				}

				$2.type = $1.type;
				$2.size = -1;
				BaseRecord* record = new Record($2.name, $1.type, offsets.top());
				tables.top().table.push_back(record);
				// cout << $2.name << " before: " << offsets.top() << endl;
				offsets.top()++;
				// cout << $2.name << " after: " << offsets.top() << endl;

				
				if($2.type != _BOOL){
					CodeBuffer.emit("subu $sp,$sp,4");
					CodeBuffer.emit("sw $" + NumberToString($4.place) + ",($sp)");
					// $1.val = $3.val;				
				}
				else {
					if($4.place == -1){
						$4.place = get_empty_reg();
					}
					// if($2.place == -1){
					// 	$2.place = get_empty_reg();
					// }
					CodeBuffer.bpatch($4.trueList,CodeBuffer.genLabel());
					CodeBuffer.emit("li $" + NumberToString($4.place) + ",1");
					int afterTrue = CodeBuffer.emit("j ");
					CodeBuffer.bpatch($4.falseList,CodeBuffer.genLabel());
					CodeBuffer.emit("li $" + NumberToString($4.place) + ",0");
					CodeBuffer.bpatch(CodeBuffer.makelist(afterTrue),CodeBuffer.genLabel());
					CodeBuffer.emit("subu $sp,$sp,4");
					CodeBuffer.emit("sw $" + NumberToString($4.place) + ",($sp)");	
				}
				free_reg($2.place);
				$2.place = -1;
				free_reg($4.place);
				$4.place = -1;

				// cout << "var " << $2.name ;
				// cout << ": ";
				// for(int i = 0; i < 18; i++){
				// 	if(regsStack.top()[i] == 1){
				// 		cout << (i + 8);
				// 		cout << ", ";
				// 	}
				// }
				// cout << "StackSize = " << regsStack.size() << endl;

			}
			| Type ID LBRACK NUM RBRACK SC
			{ 				
				type_t type;
				int size, res;
				if(check_func_exist($2.name, vector<Var>(),NULL)){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				res = get_arr_size_and_type($2.name, &type, &size);
				type = get_variable_type($2.name);
				if(res == 0 || type != _NULL){
					
					errorDef(yylineno, $2.name);
					exit(0);
				}
				if($4.val <= 0 || $4.val >= 256){
					errorInvalidArraySize(yylineno,$2.name);
					exit(0);
				}
				$2.type = $1.type;
				$2.size = $4.val;
				
				BaseRecord* record = new ArrRecord($2.name, $1.type, offsets.top(), $2.size);
				tables.top().table.push_back(record);
				offsets.top()+=$2.size;

				// CodeBuffer.emit("subu $sp,$sp," + NumberToString($2.size*4)); // space in stack for array
				for(int i = 0; i < $2.size; i++){ // allocate array in stack and zero cells
					CodeBuffer.emit("subu $sp,$sp,4");
					CodeBuffer.emit("sw $0,($sp)");
				}
				// CodeBuffer.emit("move $" + NumberToString($2.place) + ",0");
				// CodeBuffer.emit("sw $" + NumberToString($2.place) + ",($sp)");
				free_reg($2.place);
				$2.place = -1;
				free_reg($4.place);
				$4.place = -1;
			}
			| Type ID LBRACK NUM B RBRACK SC
			{ 				
				type_t type;
				int size, res;
				if(check_func_exist($2.name, vector<Var>(),NULL)){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				res = get_arr_size_and_type($2.name, &type, &size);
				type = get_variable_type($2.name);
				if(res == 0 || type != _NULL){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				if($4.val <= 0){
					errorInvalidArraySize(yylineno,$2.name);
					exit(0);
				}
				if($4.val >= 256){
					errorByteTooLarge(yylineno,NumberToString($4.val));
					exit(0);
				}
				$2.type = $1.type;
				$2.size = $4.val;
				
				BaseRecord* record = new ArrRecord($2.name, $1.type, offsets.top(), $2.size);
				tables.top().table.push_back(record);
				offsets.top()+=$2.size;

				for(int i = 0; i < $2.size; i++){ // allocate array in stack and zero cells
					CodeBuffer.emit("subu $sp,$sp,4");
					CodeBuffer.emit("sw $0,($sp)");
				}
				free_reg($2.place);
				$2.place = -1;
				free_reg($4.place);
				$4.place = -1;
			}
			| ID ASSIGN Exp SC 
			{
				type_t type1, type2;
				int size, res, offsetID, offsetExp;
				if((res = get_arr_size_and_type($1.name, &type1, &size)) == -1 && 
					(type2 = get_variable_type($1.name)) == _NULL){ // ID var or arr don't exist
					errorUndef(yylineno, $1.name);
					exit(0);
				}
				else if(res == 0){ // ID is arr
					$1.type = type1;
					$1.size = size;
					offsetID = get_arr_off($1.name);
					offsetExp = get_arr_off($3.name);
					// cout << "offsetID = " << offsetID <<endl;
					// cout << "offsetExp = " << offsetExp <<endl;
				}
				else if(type2 != _NULL){ // ID is var
					$1.type = type2;
					$1.size = -1;
					offsetID = get_variable_off($1.name);
				}

				if($3.size != $1.size){
					errorMismatch(yylineno);
					exit(0);
				}
				else if ($1.size > 0 && $3.type != $1.type){
					errorMismatch(yylineno);
					exit(0);
				}
				else if($1.type == _INT && ($3.type != _INT && $3.type != _BYTE )){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type != _INT && $1.type != $3.type){
					errorMismatch(yylineno); 
					exit(0); 
				}

				if($1.size == -1){ 
					// cout << "var = " << $1.name << endl;
					if($1.type != _BOOL){
						CodeBuffer.emit("sw $" + NumberToString($3.place) + "," + NumberToString(-4*offsetID) + "($fp)");				
						// $1.val = $3.val;				
					}
					else {
						if($3.place == -1){
							$3.place = get_empty_reg();
						}
						CodeBuffer.bpatch($3.trueList,CodeBuffer.genLabel());
						CodeBuffer.emit("li $" + NumberToString($3.place) + ",1");
						int afterTrue = CodeBuffer.emit("j ");
						CodeBuffer.bpatch($3.falseList,CodeBuffer.genLabel());
						CodeBuffer.emit("li $" + NumberToString($3.place) + ",0");
						CodeBuffer.bpatch(CodeBuffer.makelist(afterTrue),CodeBuffer.genLabel());
						// CodeBuffer.emit("subu $sp,$sp,4");
						CodeBuffer.emit("sw $" + NumberToString($3.place) + "," + NumberToString(-4*offsetID) + "($fp)");	
					}
				}
				else {
					int tmpReg = get_empty_reg();
					for(int i = 0; i < $1.size; i++){
						CodeBuffer.emit("lw $" + NumberToString(tmpReg) + "," + NumberToString(-4*(i+offsetExp)) + "($fp)");
						CodeBuffer.emit("sw $" + NumberToString(tmpReg) + "," + NumberToString(-4*(i+offsetID)) + "($fp)");				
					}
					free_reg(tmpReg);
				}
				free_reg($3.place);
				$3.place = -1;
				free_reg($1.place);
				$1.place = -1;

			}
			| ID LBRACK Exp RBRACK ASSIGN Exp SC
			{				
				type_t type = _NULL, type1 = _NULL, type2;
				int size, res;
				if((type1 = get_variable_type($1.name)) != _NULL){
					errorMismatch(yylineno); 
					exit(0);				
				}

				res = get_arr_size_and_type($1.name, &type, &size);
				if(res == -1){
					errorUndef(yylineno, $1.name);
					exit(0);
				} 	
				$1.type = type;
				$1.size = size;

				if((res = get_arr_size_and_type($6.name, &type1, &size)) == -1 && 
					(type2 = get_variable_type($6.name)) == _NULL){ // ID var or arr don't exist
					
				}
				else if(res == 0){ // ID is arr
					$6.type = type1;
				}
				else if(type2 != _NULL){ // ID is var
					$6.type = type2;
					$6.size = -1;
				}
				
				if($6.size != -1){
					errorMismatch(yylineno); 
					exit(0); 
				}
				if($3.type != _INT && $3.type != _BYTE){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _INT && ($6.type != _INT && $6.type != _BYTE )){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _BYTE && $6.type != _BYTE){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _BOOL && $6.type !=_BOOL){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _STRING && $6.type !=_STRING){
					errorMismatch(yylineno); 
					exit(0); 
				}


				int tmpReg = get_empty_reg()
				, sizeReg = get_empty_reg();
				CodeBuffer.emit("li $" + NumberToString(sizeReg) + "," + NumberToString(size));
				CodeBuffer.emit("ble $" + NumberToString(sizeReg) + ",$" + NumberToString($3.place) + ",IndexOutOfBounds");
				CodeBuffer.emit("blt $" + NumberToString($3.place) + ",$0" + ",IndexOutOfBounds");			
				free_reg(sizeReg);
				int offset = get_arr_off($1.name);
				// cout << "offset = " << offset << endl;
				// cout << "val  = " << $3.val << endl;

				if($1.type == _BOOL){
					if($6.place == -1){
						$6.place = get_empty_reg();
					}
					CodeBuffer.bpatch($6.trueList,CodeBuffer.genLabel());
					CodeBuffer.emit("li $" + NumberToString($6.place) + ",1");
					int afterTrue = CodeBuffer.emit("j ");
					CodeBuffer.bpatch($6.falseList,CodeBuffer.genLabel());
					CodeBuffer.emit("li $" + NumberToString($6.place) + ",0");
					CodeBuffer.bpatch(CodeBuffer.makelist(afterTrue),CodeBuffer.genLabel());
					// CodeBuffer.emit("subu $sp,$sp,4");
				}
				CodeBuffer.emit("mul $" + NumberToString($3.place) + ",$" + NumberToString($3.place) + ",-4"); // array index				
				CodeBuffer.emit("addu $" + NumberToString($3.place) + ",$" + NumberToString($3.place) + ",$fp"); // index + fp
				CodeBuffer.emit("li $" + NumberToString(tmpReg) + "," + NumberToString(offset*-4)); // array offset
				CodeBuffer.emit("addu $" + NumberToString($3.place) + ",$" + NumberToString($3.place) + ",$" + NumberToString(tmpReg)); // index + fp + offset
				CodeBuffer.emit("sw $" + NumberToString($6.place) + ",($" + NumberToString($3.place) + ")");				
				
				free_reg(tmpReg);
				free_reg($1.place);
				$1.place = -1;
				free_reg($6.place);
				$6.place = -1;
				free_reg($3.place);
				$3.place = -1;
				// cout << "here" << endl;
			}
			| Call SC
			| RETURN SC 
			{ 
				if(funcType == _NULL){
					errorSyn(yylineno); 
					exit(0);
				}
				if(funcType != _VOID){ 
					errorMismatch(yylineno); 
					exit(0); 
				}

				string offset = NumberToString(get_offset_of_vars_in_stack()*4);
				CodeBuffer.emit("subu $sp,$sp," + offset);
				CodeBuffer.emit("jr $ra");
			}
			| RETURN Exp SC 
			{ 				
				if(funcType == _NULL){ 
					errorSyn(yylineno); 
					exit(0); 
				}
				if (funcType == _INT && ($2.type != _INT && $2.type != _BYTE)){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if(funcType != _INT && funcType != $2.type){ 
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($2.size != -1){
					errorMismatch(yylineno); 
					exit(0);
				}
				else if(funcType == _VOID){
					errorMismatch(yylineno); 
					exit(0);					
				}

				if($2.type == _VOID){
					$$.place = -1;
				}
				else if($2.type != _BOOL){
					CodeBuffer.emit("move $v0,$" + NumberToString($2.place));
					$$.place = 2;					
				}
				else {
					if($2.place == -1){
						$2.place = get_empty_reg();
					}
					CodeBuffer.bpatch($2.trueList,CodeBuffer.genLabel());
					CodeBuffer.emit("li $" + NumberToString($2.place) + ",1");
					int afterTrue = CodeBuffer.emit("j ");
					CodeBuffer.bpatch($2.falseList,CodeBuffer.genLabel());
					CodeBuffer.emit("li $" + NumberToString($2.place) + ",0");
					CodeBuffer.bpatch(CodeBuffer.makelist(afterTrue),CodeBuffer.genLabel());
					CodeBuffer.emit("move $v0,$" + NumberToString($2.place));	
				}
				free_reg($2.place);
				$2.place = -1;
				string offset = NumberToString(get_offset_of_vars_in_stack()*4);
				CodeBuffer.emit("subu $sp,$sp," + offset);
				CodeBuffer.emit("jr $ra");

			}
			| IF LPAREN IfExp RPAREN OPENSCOPEIF M Statement CLOSESCOPEIF %prec IFX
			{
				$$.nextList = $7.nextList;
				// cout << $6.quad << endl;
				CodeBuffer.bpatch($3.trueList,$6.quad);
				CodeBuffer.bpatch($3.falseList,CodeBuffer.genLabel());
				
			}

			| IF LPAREN IfExp RPAREN OPENSCOPEIF  M Statement CLOSESCOPEIF ELSE OPENSCOPEIF N M Statement CLOSESCOPEIF
			{
				$$.nextList = CodeBuffer.merge($7.nextList, $13.nextList);	
				CodeBuffer.bpatch($3.trueList, $6.quad);
				CodeBuffer.bpatch($3.falseList, $12.quad);
				CodeBuffer.bpatch($11.nextList,CodeBuffer.genLabel());
			}

			| WHILE M LPAREN Exp RPAREN 	
			{ 
				whileStack.push(1); 
				if($4.type != _BOOL){
					errorMismatch(yylineno);
					exit(0);
				} 

			} OPENSCOPEIF M Statement N CLOSESCOPEIF M
			{ 
				whileStack.pop(); 
				CodeBuffer.bpatch($4.trueList, $8.quad);
				CodeBuffer.bpatch($10.nextList, $2.quad);
				CodeBuffer.bpatch(CodeBuffer.merge($9.nextList, $4.falseList),$12.quad);
				free_reg($4.place);
				$4.place = -1;
			}
			| BREAK SC N
			{ 
				if(whileStack.empty() || !whileStack.top()){ 
					errorUnexpectedBreak(yylineno); 
					exit(0);
				}
				string offset = NumberToString(get_offset_of_vars_in_stack()*4);
				// cout << offset << endl;
				CodeBuffer.emit("addu $sp,$sp," + offset);
				$$.nextList = $3.nextList;
				
			}
			;

IfExp 	: Exp 			
		{			
			if($1.type != _BOOL){
			
				errorMismatch(yylineno);
				exit(0);
			}

			$$ = $1;
		}
		;
Call	: ID LPAREN P ExpList RPAREN
 		{
 			int size = 0, offset, argsOffSum = 0;
 			type_t type;
			if(!check_func_exist($1.name, callParams.top(), &type)){
				errorUndefFunc(yylineno, $1.name);
				exit(0);
			}

			$$.type = $1.type = type;
			// int reg = get_empty_reg();
			// cout << $1.name << ": " << "reg = " << reg << endl;
			// free_reg(reg);
			// cout << "begin " << $1.name ;
			// cout << ": ";
			// for(int i = 0; i < 18; i++){
			// 	if(regsStack.top()[i] == 1){
			// 		cout << (i + 8);
			// 		cout << ", ";
			// 	}
			// }
			// cout << "StackSize = " << regsStack.size() << endl;

			push_regs();
			CodeBuffer.emit("addu $sp,$sp,-4");
			CodeBuffer.emit("sw $fp,($sp)");
			CodeBuffer.emit("addu $sp,$sp,-4");
			CodeBuffer.emit("sw $ra,($sp)");
			for(vector<Var>::iterator it = callParams.top().begin(); it != callParams.top().end(); ++it){
				size = it->size;
				if(it->place == -1){
					// cout << $1.name << " here " << it->type << endl;
					it->place = get_empty_reg();
				}
				if(size == -1){ // variable parameter
					if(it->type == _STRING){
						CodeBuffer.emit("la $" + NumberToString(it->place) + ",string" + NumberToString(numOfStrings-1));
					}
					
					CodeBuffer.emit("addu $sp,$sp,-4");
					CodeBuffer.emit("sw $" + NumberToString(it->place) + ",($sp)");
				}
				else { // array parameter
					offset = get_arr_off(it->name);
					for(int i = 0; i < size; i++){
						CodeBuffer.emit("lw $" + NumberToString(it->place) + "," + NumberToString(-4*(i+offset)) + "($fp)");						
						CodeBuffer.emit("addu $sp,$sp,-4");
						CodeBuffer.emit("sw $" + NumberToString(it->place) + ",($sp)");				
					}
				}
				free_reg(it->place);
				it->place = -1;
				argsOffSum += (size == -1) ? 1 : size;
			}
			// cout << argsOffSum << endl;
			// for(vector<Var>::iterator it = callParams.top().begin(); it != callParams.top().end(); ++it){
			// 	free_reg(it->place);
			// 	it->place = -1;
			// }

			CodeBuffer.emit("addu $fp,$sp,-4");
			CodeBuffer.emit("jal " + NumberToString($1.name));
			// if($1.type == _VOID){
			// 	string offset = NumberToString(get_offset_of_vars_in_stack()*4);
			// 	// cout << offset << endl;
			// 	CodeBuffer.emit("addu $sp,$sp," + offset);
			// }
			CodeBuffer.emit("addu $sp,$sp," + NumberToString(argsOffSum*4)); // delete parameters from stack
			CodeBuffer.emit("lw $ra,($sp)"); // old ra
			CodeBuffer.emit("addu $sp,$sp,4");
			CodeBuffer.emit("lw $fp,($sp)"); // old fp
			CodeBuffer.emit("addu $sp,$sp,4");			
			pop_regs();
			callParams.pop();

			// cout << "end " << $1.name ;
			// cout << ": ";
			// for(int i = 0; i < 18; i++){
			// 	if(regsStack.top()[i] == 1){
			// 		cout << (i + 8);
			// 		cout << ", ";
			// 	}
			// }
			// cout << "StackSize = " << regsStack.size() << endl;
		
		}
		| ID LPAREN RPAREN 
		{
 			type_t type;			
			if(!check_func_exist($1.name, vector<Var>(),&type)){
				errorUndefFunc(yylineno, $1.name);
				exit(0);
			}
			$$.type = $1.type = type;

			push_regs();
			CodeBuffer.emit("addu $sp,$sp,-4");
			CodeBuffer.emit("sw $fp,($sp)");
			CodeBuffer.emit("addu $sp,$sp,-4");
			CodeBuffer.emit("sw $ra,($sp)");
			CodeBuffer.emit("addu $fp,$sp,-4");
			CodeBuffer.emit("jal " + NumberToString($1.name));
			CodeBuffer.emit("lw $ra,($sp)");
			CodeBuffer.emit("addu $sp,$sp,4");
			CodeBuffer.emit("lw $fp,($sp)");
			CodeBuffer.emit("addu $sp,$sp,4");
			pop_regs();
		}
		;

P 	: { callParams.push(vector<Var>()); }
	;

ExpList	: Exp 
		{ 			
			Var var = $1;
			if(var.type == _BOOL){
				if(var.place == -1){
					var.place = get_empty_reg();
				}
				CodeBuffer.bpatch(var.trueList,CodeBuffer.genLabel());
				CodeBuffer.emit("li $" + NumberToString(var.place) + ",1");
				int afterTrue = CodeBuffer.emit("j ");
				CodeBuffer.bpatch(var.falseList,CodeBuffer.genLabel());
				CodeBuffer.emit("li $" + NumberToString(var.place) + ",0");
				CodeBuffer.bpatch(CodeBuffer.makelist(afterTrue),CodeBuffer.genLabel());
				free_reg(var.place);
				var.place = -1;
			}
			free_reg($1.place);
			$1.place = -1;
			callParams.top().push_back(var);
			// $$ = var;
			// free_reg($$.place);
			// $$.place = -1; 
		}
		| Exp
		{ 			
			Var var = $1;
			if(var.type == _BOOL){
				if(var.place == -1){
					var.place = get_empty_reg();
				}
				CodeBuffer.bpatch(var.trueList,CodeBuffer.genLabel());
				CodeBuffer.emit("li $" + NumberToString(var.place) + ",1");
				int afterTrue = CodeBuffer.emit("j ");
				CodeBuffer.bpatch(var.falseList,CodeBuffer.genLabel());
				CodeBuffer.emit("li $" + NumberToString(var.place) + ",0");
				CodeBuffer.bpatch(CodeBuffer.makelist(afterTrue),CodeBuffer.genLabel());
				free_reg(var.place);
				var.place = -1;
			}
			free_reg($1.place);
			$1.place = -1;
			callParams.top().push_back(var);
			// $$ = var;
			// free_reg(var..place);
			// $$.place = -1;
		} COMMA ExpList 

		;

Type 	: INT { $$.type = _INT; }
		| BYTE { $$.type = _BYTE; }
		| BOOL { $$.type = _BOOL; }
		;

Exp 	: LPAREN Exp RPAREN { $$ = $2; }
		| ID LBRACK Exp RBRACK	
		{ 			
			int res, size, offset;
			type_t type1, type2;

			if((res = get_arr_size_and_type($1.name, &type1, &size)) == -1 && 
				(type2 = get_variable_type($1.name)) == _NULL){ // ID var or arr don't exist
				errorUndef(yylineno, $1.name);
				exit(0);
			}
			else if(res == 0){ // ID is arr
				$1.type = type1;
				$1.size = size;
			}
			else if(type2 != _NULL){ // ID is var
				errorMismatch(yylineno);
				exit(0);
			}

			$1.type = type1;
			if((res = get_arr_size_and_type($3.name, &type1, &size)) == -1 && 
				(type2 = get_variable_type($3.name)) == _NULL){ // ID var or arr don't exist

			}
			else if(res == 0){ // ID is arr
				$3.type = type1;
				$3.size = size;
			}
			else if(type2 != _NULL){ // ID is var
				
				$3.type = type2;
				$3.size = -1;
			}
			
			if($3.type != _BYTE && $3.type != _INT){
				errorMismatch(yylineno);
				exit(0);
			}
			$$.size = -1;
			$$.type = $1.type;
			// cout << "size = " << size << endl;
			CodeBuffer.emit("bge $" + NumberToString($3.place) + "," + NumberToString(size) + ",IndexOutOfBounds");
			CodeBuffer.emit("blt $" + NumberToString($3.place) + ",$0" + ",IndexOutOfBounds");
			
			offset = get_arr_off($1.name);
			if($1.place == -1){	
				$1.place = get_empty_reg();
			}
			CodeBuffer.emit("mul $" + NumberToString($3.place) + ",$" + NumberToString($3.place) + ",-4"); // array index				
			CodeBuffer.emit("addu $" + NumberToString($3.place) + ",$" + NumberToString($3.place) + ",$fp"); // index + fp
			CodeBuffer.emit("li $" + NumberToString($1.place) + "," + NumberToString(offset*-4)); // array offset
			CodeBuffer.emit("addu $" + NumberToString($3.place) + ",$" + NumberToString($3.place) + ",$" + NumberToString($1.place)); // index + fp + offset
			CodeBuffer.emit("lw $" + NumberToString($1.place) + ",($" + NumberToString($3.place) + ")");
			free_reg($3.place);
			$3.place = -1;
			if($1.type == _BOOL){
				$$.trueList = CodeBuffer.makelist(CodeBuffer.emit("beq $" + NumberToString($1.place) + ",1,"));
				$$.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
				free_reg($1.place);
				$1.place = -1;
			} 
			$$.place = $1.place;

			// free_reg($1.place);
			
			

		} 
		| Exp SUB Exp 
		{ 
			match_operands($1.type,$3.type,true); 
			if($1.type == _INT || $3.type == _INT){
				$$.type = _INT;
			}
			else {
				$$.type = _BYTE;
			} 
			$$.size = -1;

			CodeBuffer.emit("subu $" + NumberToString($$.place) + ",$" + NumberToString($1.place) + ",$" + NumberToString($3.place));
			if($1.type == _BYTE && $3.type == _BYTE){
				// cout << "hereee" <<endl;
				CodeBuffer.emit("li $" + NumberToString($3.place) + ",0x000000ff");
				CodeBuffer.emit("and $" + NumberToString($1.place)+ ",$" + NumberToString($1.place) +",$" + NumberToString($3.place));
				// CodeBuffer.emit("div $" + NumberToString($$.place)+ ",$" + NumberToString($3.place));
				// CodeBuffer.emit("mfhi $" + NumberToString($$.place));
			}
			$$.place = $1.place;
			free_reg($3.place);
			$3.place = -1;
		}
		| Exp ADD Exp 
		{ 
			match_operands($1.type,$3.type,true); 
			if($1.type == _INT || $3.type == _INT){
				$$.type = _INT;
			}
			else {
				$$.type = _BYTE;
			} 
			$$.size = -1;

			// cout << "here" << endl;
			CodeBuffer.emit("addu $" + NumberToString($1.place) + ",$" + NumberToString($1.place) + ",$" + NumberToString($3.place));
			if($1.type == _BYTE && $3.type == _BYTE){
				// cout << "hereee" <<endl;
				CodeBuffer.emit("li $" + NumberToString($3.place) + ",0x000000ff");
				CodeBuffer.emit("and $" + NumberToString($1.place)+ ",$" + NumberToString($1.place) +",$" + NumberToString($3.place));
				// CodeBuffer.emit("div $" + NumberToString($$.place)+ ",$" + NumberToString($3.place));
				// CodeBuffer.emit("mfhi $" + NumberToString($$.place));
			}
			$$.place = $1.place;
			free_reg($3.place);
			$3.place = -1;
		}		
		| Exp MUL Exp
		{ 
			match_operands($1.type,$3.type,true); 
			if($1.type == _INT || $3.type == _INT){
				$$.type = _INT;
			}
			else {
				$$.type = _BYTE;
			} 
			$$.size = -1;

			CodeBuffer.emit("mul $" + NumberToString($$.place) + ",$" + NumberToString($1.place) + ",$" + NumberToString($3.place));
			if($1.type == _BYTE && $3.type == _BYTE){
				// cout << "hereee" <<endl;
				CodeBuffer.emit("li $" + NumberToString($3.place) + ",0x000000ff");
				CodeBuffer.emit("and $" + NumberToString($1.place)+ ",$" + NumberToString($1.place) +",$" + NumberToString($3.place));
				// CodeBuffer.emit("div $" + NumberToString($$.place)+ ",$" + NumberToString($3.place));
				// CodeBuffer.emit("mfhi $" + NumberToString($$.place));
			}
			$$.place = $1.place;
			free_reg($3.place);
			$3.place = -1;
		}
		| Exp DIV Exp
		{ 
			match_operands($1.type,$3.type,true); 
			if($1.type == _INT || $3.type == _INT){
				$$.type = _INT;
			}
			else {
				$$.type = _BYTE;
			} 
			$$.size = -1;

			CodeBuffer.emit("beq $" + NumberToString($3.place) + ",0,ZeroDivision");
			CodeBuffer.emit("div $" + NumberToString($1.place) + ",$" + NumberToString($1.place) + ",$" + NumberToString($3.place));
			if($1.type == _BYTE && $3.type == _BYTE){
				// cout << "hereee" <<endl;
				CodeBuffer.emit("li $" + NumberToString($3.place) + ",0x000000ff");
				CodeBuffer.emit("and $" + NumberToString($1.place)+ ",$" + NumberToString($1.place) +",$" + NumberToString($3.place));
				// CodeBuffer.emit("div $" + NumberToString($$.place)+ ",$" + NumberToString($3.place));
				// CodeBuffer.emit("mfhi $" + NumberToString($$.place));
			}
			$$.place = $1.place;			
			free_reg($3.place);
			$3.place = -1;		
		}
		| ID
		{ 			
			type_t type1, type2;
			int size, res, offset;
			if((res = get_arr_size_and_type($1.name, &type1, &size)) == -1 && 
				(type2 = get_variable_type($1.name)) == _NULL){ // ID var or arr don't exist
				errorUndef(yylineno, $1.name);
				exit(0);
			}
			else if(res == 0){ // ID is arr
				$1.type = type1;
				$1.size = size;
			}
			else if(type2 != _NULL){ // ID is var			
				$1.type = type2;
				$1.size = -1;
				if($1.place == -1){
					$1.place = get_empty_reg();
				}
				offset = get_variable_off($1.name);
				// cout << "name =" << $1.name << " offset = " << offset*-4 << endl;
				CodeBuffer.emit("lw $" + NumberToString($1.place) + "," + NumberToString(offset*-4) + "($fp)");
				if($1.type == _BOOL){
					$1.trueList = CodeBuffer.makelist(CodeBuffer.emit("beq $" + NumberToString($1.place) + ",1,"));
					$1.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
					free_reg($1.place);
					$1.place = -1;
				} 
			}
			$$ = $1;
	

	
		}
		| Call 
		{ 
			$1.size = -1;
			// cout << "callReg = " << $1.place << endl;
			if($1.place == -1){
				$1.place = get_empty_reg();
			}

			if($1.type == _INT || $1.type == _BYTE){
				CodeBuffer.emit("move $" + NumberToString($1.place) + ",$v0");
			}
			else if ($1.type == _VOID){
				free_reg($1.place);
				$1.place = -1;
			}
			if($1.type == _BOOL){
				$1.trueList = CodeBuffer.makelist(CodeBuffer.emit("beq $" + NumberToString($1.place) + ",1,"));
				$1.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
				free_reg($1.place);
				$1.place = -1;
			} 
			$$ = $1;



		}
		| NUM 
		{ 
			$$.type = _INT; 
			$$.val = $1.val; 
			$$.size = -1;

			
			$$.place = get_empty_reg();
			CodeBuffer.emit("li $" + NumberToString($$.place) + "," + NumberToString($1.val));
		}
		| NUM B 
		{ 			
			if($1.val < 0 || $1.val >= 256){
				errorByteTooLarge(yylineno,NumberToString($1.val));
				exit(0);
			}
			$$.type = _BYTE; 
			$$.val = $1.val;
			$$.size = -1;

			$$.place = get_empty_reg();
			CodeBuffer.emit("li $" + NumberToString($$.place) + "," + NumberToString($1.val)); 
		}
		| STRING  
		{ 
			string str = yytext;
			// cout << str << endl;
			$$.type = _STRING; 
			$$.size = -1;
			// $$.place = $1.place = get_empty_reg(); 
			CodeBuffer.emitData("string" + NumberToString(numOfStrings++) + ":	.asciiz " + NumberToString(str));
		}
		| TRUE 
		{ 
			$$.type = _BOOL; 
			$$.size = -1;

			$$.trueList = CodeBuffer.makelist(CodeBuffer.emit("j "));
		}
		| FALSE 
		{ 
			$$.type = _BOOL; 
			$$.size = -1;

			$$.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
		}
		| NOT Exp 
		{ 
			if($2.type != _BOOL){
				
				errorMismatch(yylineno);
				exit(0);
			} 
			$$.type = _BOOL;
			$$.size = -1;

			$$.trueList = $2.falseList;
			$$.falseList = $2.trueList;
			free_reg($2.place);
			$2.place = -1;
		}
		| Exp AND M Exp 
		{ 
			// cout << "here" << endl;
			match_operands($1.type,$4.type,false); 
			$$.type = _BOOL; 
			$$.size = -1;

			CodeBuffer.bpatch($1.trueList,$3.quad); 
			$$.trueList = $4.trueList; 
			$$.falseList = CodeBuffer.merge($1.falseList,$4.falseList);
			free_reg($1.place);
			free_reg($4.place);
			$1.place = -1;
			$4.place = -1;
		}
		| Exp OR M Exp 
		{ 
			match_operands($1.type,$4.type,false); 
			$$.type = _BOOL; 
			$$.size = -1;

			CodeBuffer.bpatch($1.falseList,$3.quad); 
			$$.trueList = CodeBuffer.merge($1.trueList,$4.trueList); 
			$$.falseList  = $4.falseList;
			free_reg($1.place);
			free_reg($4.place);
			$1.place = -1;
			$4.place = -1;
		}
		| Exp EQ Exp 
		{ 
			match_operands($1.type,$3.type,true); 
			$$.type = _BOOL; 
			$$.size = -1;

			$$.trueList = CodeBuffer.makelist(CodeBuffer.emit("beq $" + NumberToString($1.place) + ",$" + NumberToString($3.place) + ","));
			$$.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
			free_reg($1.place);
			free_reg($3.place);
			$1.place = -1;
			$3.place = -1;
		}
		| Exp NEQ Exp 
		{ 
			match_operands($1.type,$3.type,true); 
			$$.type = _BOOL; 
			$$.size = -1;

			$$.trueList = CodeBuffer.makelist(CodeBuffer.emit("bne $" + NumberToString($1.place) + ",$" + NumberToString($3.place) + ","));
			$$.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
			free_reg($1.place);
			free_reg($3.place);
			$1.place = -1;
			$3.place = -1;
		}
		| Exp LT Exp 
		{ 
			match_operands($1.type,$3.type,true); 
			$$.type = _BOOL; 
			$$.size = -1;

			$$.trueList = CodeBuffer.makelist(CodeBuffer.emit("blt $" + NumberToString($1.place) + ",$" + NumberToString($3.place) + ","));
			$$.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
			free_reg($1.place);
			free_reg($3.place);
			$1.place = -1;
			$3.place = -1;		
		}
		| Exp GT Exp 
		{ 
			match_operands($1.type,$3.type,true); 
			$$.type = _BOOL; 
			$$.size = -1;

			$$.trueList = CodeBuffer.makelist(CodeBuffer.emit("bgt $" + NumberToString($1.place) + ",$" + NumberToString($3.place) + ","));
			$$.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
			free_reg($1.place);
			free_reg($3.place);
			$1.place = -1;
			$3.place = -1;
		}
		| Exp LTE Exp 
		{ 
			match_operands($1.type,$3.type,true); 
			$$.type = _BOOL; 
			$$.size = -1;

			$$.trueList = CodeBuffer.makelist(CodeBuffer.emit("ble $" + NumberToString($1.place) + ",$" + NumberToString($3.place) + ", "));
			$$.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
			free_reg($1.place);
			free_reg($3.place);
			$1.place = -1;
			$3.place = -1;
		}
		| Exp GTE Exp 
		{ 
			match_operands($1.type,$3.type,true); 
			$$.type = _BOOL; 
			$$.size = -1;

			$$.trueList = CodeBuffer.makelist(CodeBuffer.emit("bge $" + NumberToString($1.place) + ",$" + NumberToString($3.place) + ", "));
			$$.falseList = CodeBuffer.makelist(CodeBuffer.emit("j "));
			free_reg($1.place);
			free_reg($3.place);
			$1.place = -1;
			$3.place = -1;
		}
		;

M 	: { $$.quad = CodeBuffer.genLabel(); }
	;

N 	: 
	{ 
		$$.quad = CodeBuffer.genLabel(); 
		$$.nextList = CodeBuffer.makelist(CodeBuffer.emit("j "));
	}

// OPENSCOPE	: {
// 				Tuple tuple;
// 				tuple.parent = &(tables.top());
// 				tables.push(tuple);
// 				// cout << " size : " << offsets.size() << endl;
// 				offsets.push(offsets.top());
// 				// cout << " size : " << offsets.size() << endl;
// 			}
// 			;

CLOSESCOPE	: {
				//endScope();
				Tuple* tuple = &(tables.top());
				vector<BaseRecord*>* table = &(tuple->table);
				
				Record* record;
				ArrRecord* arrRecord;
				FuncRecord* funcRecord;
				for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
					arrRecord = dynamic_cast<ArrRecord*>(*it);
					if(arrRecord != NULL){ // record of array
						//printID(arrRecord->name,arrRecord->offset,makeArrayType(types[arrRecord->type],arrRecord->size));
						continue;
					}

					record = dynamic_cast<Record*>(*it);
					if(record != NULL){ // record of variable	
						//printID(record->name, record->offset, types[record->type]);
						continue;
					}

					funcRecord = dynamic_cast<FuncRecord*>(*it);
					if(funcRecord != NULL){ // record of function
						vector<string> tmp;
						for(vector<Var>::iterator it = funcRecord->args.begin(); it != funcRecord->args.end(); ++it){
							if(it->size > 0){
								tmp.push_back(types[it->type]+'['+NumberToString(it->size)+']');
								continue;
							}
							tmp.push_back(types[it->type]);

						}
						//printID(funcRecord->name, 0, makeFunctionType(types[funcRecord->type],tmp));
						continue;
					}
				}
				tables.pop();
				offsets.pop();
			}
			;

OPENSCOPEIF	: {
				Tuple tuple;
				tuple.parent = &(tables.top());
				tables.push(tuple);
				// cout << " ifsize : " << offsets.size() << endl;
				// cout << "startoffset: " << offsets.top() <<" size : " << offsets.size() << endl;
				offsets.push(offsets.top());
				// cout << " ifsize : " << offsets.size() << endl;
				// cout << "startoffset: " << offsets.top() <<" size : " << offsets.size() << endl;
			}
			;

CLOSESCOPEIF	: {
				//endScope();
				// cout << "endoffset: " << offsets.top() << " size : " << offsets.size() << endl;
				string offset = NumberToString(get_offset_of_vars_in_stack()*4);
				CodeBuffer.emit("addu $sp,$sp," + offset);

				Tuple* tuple = &(tables.top());
				vector<BaseRecord*>* table = &(tuple->table);
				
				Record* record;
				ArrRecord* arrRecord;
				FuncRecord* funcRecord;
				for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
					arrRecord = dynamic_cast<ArrRecord*>(*it);
					if(arrRecord != NULL){ // record of array
						//printID(arrRecord->name,arrRecord->offset,makeArrayType(types[arrRecord->type],arrRecord->size));
						continue;
					}

					record = dynamic_cast<Record*>(*it);
					if(record != NULL){ // record of variable	
						//printID(record->name, record->offset, types[record->type]);
						continue;
					}

					funcRecord = dynamic_cast<FuncRecord*>(*it);
					if(funcRecord != NULL){ // record of function
						vector<string> tmp;
						for(vector<Var>::iterator it = funcRecord->args.begin(); it != funcRecord->args.end(); ++it){
							if(it->size > 0){
								tmp.push_back(types[it->type]+'['+NumberToString(it->size)+']');
								continue;
							}
							tmp.push_back(types[it->type]);

						}
						//printID(funcRecord->name, 0, makeFunctionType(types[funcRecord->type],tmp));
						continue;
					}
				}
				tables.pop();
				offsets.pop();
			}
			;
%%

int main()
{
	vector<int> mainRegs(18,0);
	regsStack.push(mainRegs);
	yyparse();
	CodeBuffer.printCodeBuffer();
	CodeBuffer.printDataBuffer();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	exit(0);
}

/* flag == true checks for numeric types, type == false checks for bool value */
void match_operands(type_t type1, type_t type2, bool flag){
	
	if (flag == true){
		if((type1 != _INT && type1 != _BYTE) || (type2 != _INT && type2 != _BYTE)){
			errorMismatch(yylineno);
			exit(0);
		}
	}
	else if (flag == false){
		if((type1 != _BOOL) || (type2 != _BOOL)){
			errorMismatch(yylineno);
			exit(0);
		}
	}
}

/* return true if varialbe was declared, false if not */
type_t get_variable_type(string name){
	Tuple *tuple = &(tables.top());
	vector<BaseRecord*>* table;
	Record* record;
	ArrRecord* arrRecord;
	while(tuple != NULL){
		table = &(tuple->table);
		for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
			arrRecord = dynamic_cast<ArrRecord*>(*it);
			if(arrRecord != NULL){
				continue;
			}

			record = dynamic_cast<Record*>(*it);
			if(record == NULL){
				continue;
			}
			if(record->name == name){
				return record->type;
			}
		}
		tuple = tuple->parent;
	}
	return _NULL;
}

int get_variable_off(string name){
	Tuple *tuple = &(tables.top());
	vector<BaseRecord*>* table;
	Record* record;
	ArrRecord* arrRecord;
	while(tuple != NULL){
		table = &(tuple->table);
		for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
			arrRecord = dynamic_cast<ArrRecord*>(*it);
			if(arrRecord != NULL){
				continue;
			}

			record = dynamic_cast<Record*>(*it);
			if(record == NULL){
				continue;
			}
			if(record->name == name){
				return record->offset;
			}
		}
		tuple = tuple->parent;
	}
	return -1;
}

int get_arr_size_and_type(string name, type_t* type, int* size){
	if(!type || !size){
		return -1;
	}

	Tuple *tuple = &(tables.top());
	vector<BaseRecord*>* table;
	ArrRecord* arrRecord;
	while(tuple != NULL){
		table = &(tuple->table);
		for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
			arrRecord = dynamic_cast<ArrRecord*>(*it);
			if(arrRecord == NULL){
				continue;
			}
			if(arrRecord->name == name){
				*type = (arrRecord->type);
				*size = (arrRecord->size);
				return 0;
			}
		}
		tuple = tuple->parent;
	}
	return -1;
}

int get_arr_off(string name){
	Tuple *tuple = &(tables.top());
	vector<BaseRecord*>* table;
	ArrRecord* arrRecord;
	while(tuple != NULL){
		table = &(tuple->table);
		for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
			arrRecord = dynamic_cast<ArrRecord*>(*it);
			if(arrRecord == NULL){
				continue;
			}
			if(arrRecord->name == name){
				return arrRecord->offset;
			}
		}
		tuple = tuple->parent;
	}
	return -1;
}

bool check_func_exist(string name, vector<Var> argList, type_t* retType){
	Tuple *tuple = &(tables.top());
	vector<BaseRecord*>* table;
	vector<Var>::iterator it1,it2, tmp;
	vector<string> errorArgs;
	FuncRecord* funcRecord;
	BaseRecord* baseRecord;

	while(tuple != NULL){
		table = &(tuple->table);
		for(vector<BaseRecord*>::iterator it = tuple->table.begin(); it != tuple->table.end(); ++it){	
			funcRecord = dynamic_cast<FuncRecord*>(*it);
			if(funcRecord == NULL){
				continue;
			}
			if(funcRecord->name == name){
				if(retType == NULL){
					return true;
				}
				if(argList.size() != funcRecord->args.size()){
					for(tmp = funcRecord->args.begin(); tmp != funcRecord->args.end();++tmp){
							if(tmp->size > 0){
								errorArgs.push_back(types[tmp->type]+'['+NumberToString(tmp->size)+']');
								continue;
							}
							errorArgs.push_back(types[tmp->type]);

					}
					errorPrototypeMismatch(yylineno,name,errorArgs);
					exit(0);
				}

				for(it1 = argList.begin(),it2 = funcRecord->args.begin(); it1 != argList.end(); ++it1, ++it2){
					if((it2->type == _INT && (it1->type != _INT && it1->type != _BYTE)) ||  
						(it2->type != _INT && it2->type != it1->type) || it1->size != it2->size){
						for(tmp = funcRecord->args.begin(); tmp != funcRecord->args.end();++tmp){
							if(tmp->size > 0){
								errorArgs.push_back(types[tmp->type]+'['+NumberToString(tmp->size)+']');
								continue;
							}
							errorArgs.push_back(types[tmp->type]);
						}
						errorPrototypeMismatch(yylineno,name,errorArgs);
						exit(0);
					}
				}
				*retType = funcRecord->type;
				return true;
			}
		}
		tuple = tuple->parent;
	}
	return false;
}
void free_reg(int num){
	if(num > 25 || num < 8)
		return;
	regsStack.top()[num-8] = 0;
}


void free_reg_list(vector<int>& regs){
	for(vector<int>::iterator it = regs.begin(); it != regs.end(); ++it){
		regsStack.top()[*it-8] = 0;
	}
};

int get_empty_reg(){
	for(vector<int>::iterator it = regsStack.top().begin(); it != regsStack.top().end(); ++it){
		if(*it == 0){
			*it = 1;
			return (it - regsStack.top().begin() + 8);
		}
	}
	
	cout << "Error: all registers are in use" << endl;
	return -1;
	exit(0);
};

int get_offset_of_vars_in_stack(){
	int top = offsets.top();
	// cout << "beforetop: " << offsets.top() << endl;
	offsets.pop();
	// cout << "aftertop: " << offsets.top() << endl;
	int offset = top - offsets.top();
	offsets.push(top);
	return offset;
}

void push_regs(){
	vector<int> newRegs(18,0);
	for(vector<int>::iterator it = regsStack.top().begin(); it != regsStack.top().end(); ++it){
		if(*it == 1){
			// cout << "pushRegNum = " << *it << endl;
			CodeBuffer.emit("addu $sp,$sp,-4");
			CodeBuffer.emit("sw $" + NumberToString(it - regsStack.top().begin() + 8) + ",($sp)");	
		}
	}
	regsStack.push(newRegs);
}

void pop_regs(){
	regsStack.pop();
	for(int i = 17; i >= 0; --i){
		if(regsStack.top()[i] == 1){
			
			// cout << "popRegNum = " << *it << endl;
			CodeBuffer.emit("lw $" + NumberToString(i + 8) + ",($sp)");
			CodeBuffer.emit("addu $sp,$sp,4");	
		}
	}
}

// void print_empty_regs(){
// 	for(int i = 0; i < 18; i++){
// 		if(regsStack.top()[i] == 1){
// 			cout << (i + 8) << ", ";
// 		}
		
// 	}
// 	 endl;
// 	// return -1;
// 	// cout << "Error: all registers are in use" << endl;
// 	// exit(0);
// };